"""
Claude Code Interceptor - Claude Codeì˜ ì½”ë“œë¥¼ ìë™ìœ¼ë¡œ ê²€ì¦í•˜ëŠ” ì›Œí¬í”Œë¡œìš°
Git pre-commit hook ë° ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ì„ í†µí•´ ì½”ë“œ ë“œë¦¬í”„íŠ¸ ë°©ì§€
"""

import os
import sys
import json
import asyncio
from typing import Dict, List, Optional, Tuple
from datetime import datetime
import subprocess
import tempfile
from pathlib import Path
import hashlib

from notion_governance_integration import NotionGovernanceIntegration
from vision_guardian import VisionGuardian


class ClaudeCodeInterceptor:
    """
    Claude Codeì˜ ì½”ë“œ ë³€ê²½ì„ ê°ì§€í•˜ê³  ìë™ìœ¼ë¡œ ê²€ì¦
    Git hooks, íŒŒì¼ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§, API ì¸í„°ì…‰íŠ¸ ë“± ë‹¤ì–‘í•œ ë°©ë²• í™œìš©
    """
    
    def __init__(self, governance_integration: NotionGovernanceIntegration):
        """
        Args:
            governance_integration: Notion ê±°ë²„ë„ŒìŠ¤ í†µí•© ì‹œìŠ¤í…œ
        """
        self.governance = governance_integration
        self.monitoring_active = False
        self.validation_cache = {}  # íŒŒì¼ í•´ì‹œ -> ê²€ì¦ ê²°ê³¼ ìºì‹œ
        self.watch_directories = [
            './kimchi-premium-arbitrage/src',
            './kimchi-premium-arbitrage/backend',
            './kimchi-premium-arbitrage/strategies'
        ]
        
    def install_git_hooks(self):
        """Git pre-commit hook ì„¤ì¹˜"""
        
        hook_content = """#!/usr/bin/env python3
# Auto-generated by Claude Code Interceptor
# DO NOT EDIT MANUALLY

import sys
import os
import json
import subprocess

# í”„ë¡œì íŠ¸ ë£¨íŠ¸ ì¶”ê°€
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from executive_control.claude_code_interceptor import ClaudeCodeInterceptor
from executive_control.notion_governance_integration import NotionGovernanceIntegration

def main():
    # ìŠ¤í…Œì´ì§•ëœ íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
    result = subprocess.run(
        ['git', 'diff', '--cached', '--name-only'],
        capture_output=True,
        text=True
    )
    
    staged_files = result.stdout.strip().split('\\n')
    python_files = [f for f in staged_files if f.endswith('.py')]
    
    if not python_files:
        return 0  # Python íŒŒì¼ì´ ì—†ìœ¼ë©´ í†µê³¼
    
    print("ğŸ” Vision Guardian: Validating code changes...")
    
    # ê±°ë²„ë„ŒìŠ¤ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    config = {
        'vision_db': os.getenv('NOTION_VISION_DB'),
        'tasks_db': os.getenv('NOTION_TASKS_DB'),
        'validation_db': os.getenv('NOTION_VALIDATION_DB'),
        'dashboard_page': os.getenv('NOTION_DASHBOARD_PAGE')
    }
    
    governance = NotionGovernanceIntegration(
        os.getenv('NOTION_TOKEN'),
        config
    )
    
    interceptor = ClaudeCodeInterceptor(governance)
    
    # ê° íŒŒì¼ ê²€ì¦
    all_approved = True
    for file_path in python_files:
        with open(file_path, 'r', encoding='utf-8') as f:
            code = f.read()
        
        approved, feedback = interceptor.validate_code_sync(file_path, code)
        
        if not approved:
            print(f"\\nâŒ Validation failed for {file_path}:")
            print(feedback)
            all_approved = False
        else:
            print(f"âœ… {file_path} approved")
    
    if not all_approved:
        print("\\nâš ï¸  Code validation failed. Please fix the issues and try again.")
        print("ğŸ’¡ Tip: Review the Vision Guardian feedback above.")
        return 1
    
    print("\\nâœ… All files passed Vision Guardian validation!")
    return 0

if __name__ == '__main__':
    sys.exit(main())
"""
        
        # Git hooks ë””ë ‰í† ë¦¬ ìƒì„±
        git_dir = Path('.git/hooks')
        if not git_dir.exists():
            print("Warning: .git/hooks directory not found")
            return False
        
        # pre-commit hook ì‘ì„±
        hook_path = git_dir / 'pre-commit'
        with open(hook_path, 'w', encoding='utf-8') as f:
            f.write(hook_content)
        
        # ì‹¤í–‰ ê¶Œí•œ ì¶”ê°€ (Unix ì‹œìŠ¤í…œ)
        if sys.platform != 'win32':
            os.chmod(hook_path, 0o755)
        
        print(f"âœ… Git pre-commit hook installed at {hook_path}")
        return True
    
    def validate_code_sync(self, file_path: str, code: str) -> Tuple[bool, str]:
        """
        ë™ê¸°ì  ì½”ë“œ ê²€ì¦ (Git hookìš©)
        
        Args:
            file_path: íŒŒì¼ ê²½ë¡œ
            code: ê²€ì¦í•  ì½”ë“œ
            
        Returns:
            (ìŠ¹ì¸ ì—¬ë¶€, í”¼ë“œë°±)
        """
        # íŒŒì¼ í•´ì‹œ ê³„ì‚°
        code_hash = hashlib.md5(code.encode()).hexdigest()
        
        # ìºì‹œ í™•ì¸
        if code_hash in self.validation_cache:
            cached = self.validation_cache[code_hash]
            return cached['approved'], cached['feedback']
        
        # ì»´í¬ë„ŒíŠ¸ ì‹ë³„
        component = self._identify_component(file_path)
        
        # ê°„ë‹¨í•œ ì‘ì—… ëª…ì„¸ ìƒì„±
        task_spec = {
            'task_id': f"AUTO-{datetime.now().strftime('%Y%m%d%H%M%S')}",
            'component': component,
            'description': f"Automated validation for {file_path}"
        }
        
        # Vision Guardianìœ¼ë¡œ ê²€ì¦
        result = self.governance.vision_guardian.validate_code(code, task_spec)
        feedback = self.governance.vision_guardian.generate_feedback(result)
        
        # ìºì‹œ ì €ì¥
        self.validation_cache[code_hash] = {
            'approved': result.approved,
            'feedback': feedback,
            'timestamp': datetime.now().isoformat()
        }
        
        return result.approved, feedback
    
    def _identify_component(self, file_path: str) -> str:
        """íŒŒì¼ ê²½ë¡œì—ì„œ ì»´í¬ë„ŒíŠ¸ ì‹ë³„"""
        path_lower = file_path.lower()
        
        if 'trading' in path_lower or 'exchange' in path_lower:
            return 'trading_core'
        elif 'ml' in path_lower or 'model' in path_lower:
            return 'ml_engine'
        elif 'dashboard' in path_lower or 'ui' in path_lower:
            return 'dashboard'
        elif 'risk' in path_lower:
            return 'risk_manager'
        elif 'data' in path_lower:
            return 'data_pipeline'
        else:
            return 'general'
    
    async def start_file_monitoring(self):
        """íŒŒì¼ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        self.monitoring_active = True
        print("ğŸ” Starting file system monitoring...")
        
        # watchdog ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš© (ì„¤ì¹˜ í•„ìš”: pip install watchdog)
        try:
            from watchdog.observers import Observer
            from watchdog.events import FileSystemEventHandler
        except ImportError:
            print("Warning: watchdog not installed. Install with: pip install watchdog")
            return
        
        class CodeChangeHandler(FileSystemEventHandler):
            def __init__(self, interceptor):
                self.interceptor = interceptor
            
            def on_modified(self, event):
                if event.is_directory:
                    return
                
                if event.src_path.endswith('.py'):
                    asyncio.create_task(
                        self.interceptor.handle_file_change(event.src_path)
                    )
        
        # Observer ì„¤ì •
        event_handler = CodeChangeHandler(self)
        observer = Observer()
        
        for directory in self.watch_directories:
            if os.path.exists(directory):
                observer.schedule(event_handler, directory, recursive=True)
                print(f"  Watching: {directory}")
        
        observer.start()
        
        try:
            while self.monitoring_active:
                await asyncio.sleep(1)
        finally:
            observer.stop()
            observer.join()
    
    async def handle_file_change(self, file_path: str):
        """íŒŒì¼ ë³€ê²½ ê°ì§€ ì‹œ ì²˜ë¦¬"""
        print(f"\nğŸ“ File changed: {file_path}")
        
        # íŒŒì¼ ë‚´ìš© ì½ê¸°
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                code = f.read()
        except Exception as e:
            print(f"Error reading file: {e}")
            return
        
        # ì½”ë“œ ê²€ì¦
        approved, feedback = self.validate_code_sync(file_path, code)
        
        if not approved:
            print(f"âš ï¸  Validation warning for {file_path}:")
            print(feedback[:500])  # ì²˜ìŒ 500ìë§Œ ì¶œë ¥
            
            # Notionì— ê²½ê³  ê¸°ë¡
            await self._record_warning_to_notion(file_path, feedback)
        else:
            print(f"âœ… {file_path} passes validation")
    
    async def _record_warning_to_notion(self, file_path: str, feedback: str):
        """ê²€ì¦ ê²½ê³ ë¥¼ Notionì— ê¸°ë¡"""
        
        if not self.governance.validation_db:
            return
        
        try:
            page = self.governance.notion.pages.create(
                parent={"database_id": self.governance.validation_db},
                properties={
                    "Task ID": {"title": [{"text": {"content": f"Warning: {file_path}"}}]},
                    "Status": {"select": {"name": "Warning"}},
                    "Timestamp": {"date": {"start": datetime.now().isoformat()}},
                    "Validator": {"select": {"name": "File Monitor"}}
                },
                children=[
                    {
                        "object": "block",
                        "type": "paragraph",
                        "paragraph": {
                            "rich_text": [{"text": {"content": feedback[:2000]}}]
                        }
                    }
                ]
            )
        except Exception as e:
            print(f"Failed to record warning to Notion: {e}")
    
    def create_vscode_extension(self):
        """VS Code í™•ì¥ ì„¤ì • ìƒì„± (ì‹¤ì‹œê°„ ê²€ì¦)"""
        
        vscode_settings = {
            "editor.formatOnSave": True,
            "python.linting.enabled": True,
            "python.linting.flake8Enabled": True,
            "files.watcherExclude": {
                "**/.git/**": True,
                "**/node_modules/**": True
            },
            "tasks": {
                "version": "2.0.0",
                "tasks": [
                    {
                        "label": "Vision Guardian Validation",
                        "type": "shell",
                        "command": "python",
                        "args": [
                            "-m",
                            "executive_control.validate_current_file",
                            "${file}"
                        ],
                        "group": "build",
                        "presentation": {
                            "reveal": "always"
                        },
                        "problemMatcher": "$python"
                    }
                ]
            }
        }
        
        # .vscode ë””ë ‰í† ë¦¬ ìƒì„±
        vscode_dir = Path('.vscode')
        vscode_dir.mkdir(exist_ok=True)
        
        # settings.json ì‘ì„±
        settings_path = vscode_dir / 'settings.json'
        with open(settings_path, 'w', encoding='utf-8') as f:
            json.dump(vscode_settings, f, indent=2)
        
        print(f"âœ… VS Code settings created at {settings_path}")
        
        # í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì„¤ì •
        keybindings = [
            {
                "key": "ctrl+shift+v",
                "command": "workbench.action.tasks.runTask",
                "args": "Vision Guardian Validation"
            }
        ]
        
        keybindings_path = vscode_dir / 'keybindings.json'
        with open(keybindings_path, 'w', encoding='utf-8') as f:
            json.dump(keybindings, f, indent=2)
        
        print(f"âœ… VS Code keybindings created (Ctrl+Shift+V for validation)")
    
    def create_validation_script(self):
        """ë…ë¦½ ì‹¤í–‰ ê°€ëŠ¥í•œ ê²€ì¦ ìŠ¤í¬ë¦½íŠ¸ ìƒì„±"""
        
        script_content = """#!/usr/bin/env python3
\"\"\"
Vision Guardian Validation Script
Usage: python validate.py <file_path>
\"\"\"

import sys
import os
import asyncio
from pathlib import Path

# í”„ë¡œì íŠ¸ ë£¨íŠ¸ ì¶”ê°€
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from executive_control.claude_code_interceptor import ClaudeCodeInterceptor
from executive_control.notion_governance_integration import NotionGovernanceIntegration


async def validate_file(file_path: str):
    \"\"\"íŒŒì¼ ê²€ì¦\"\"\"
    
    # íŒŒì¼ ì¡´ì¬ í™•ì¸
    if not os.path.exists(file_path):
        print(f"Error: File not found: {file_path}")
        return 1
    
    # ì½”ë“œ ì½ê¸°
    with open(file_path, 'r', encoding='utf-8') as f:
        code = f.read()
    
    # ê±°ë²„ë„ŒìŠ¤ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    config = {
        'vision_db': os.getenv('NOTION_VISION_DB'),
        'tasks_db': os.getenv('NOTION_TASKS_DB'),
        'validation_db': os.getenv('NOTION_VALIDATION_DB'),
        'dashboard_page': os.getenv('NOTION_DASHBOARD_PAGE')
    }
    
    governance = NotionGovernanceIntegration(
        os.getenv('NOTION_TOKEN'),
        config
    )
    
    await governance.initialize_governance()
    
    interceptor = ClaudeCodeInterceptor(governance)
    
    # ê²€ì¦ ì‹¤í–‰
    print(f"ğŸ” Validating {file_path}...")
    approved, feedback = interceptor.validate_code_sync(file_path, code)
    
    print("\\n" + "="*50)
    if approved:
        print("âœ… VALIDATION PASSED")
    else:
        print("âŒ VALIDATION FAILED")
    print("="*50)
    
    print(feedback)
    
    return 0 if approved else 1


async def validate_all():
    \"\"\"ëª¨ë“  Python íŒŒì¼ ê²€ì¦\"\"\"
    
    python_files = []
    for root, dirs, files in os.walk('./kimchi-premium-arbitrage'):
        for file in files:
            if file.endswith('.py'):
                python_files.append(os.path.join(root, file))
    
    print(f"Found {len(python_files)} Python files to validate")
    
    failed_files = []
    for file_path in python_files:
        result = await validate_file(file_path)
        if result != 0:
            failed_files.append(file_path)
    
    if failed_files:
        print(f"\\nâŒ {len(failed_files)} files failed validation:")
        for f in failed_files:
            print(f"  - {f}")
        return 1
    else:
        print(f"\\nâœ… All {len(python_files)} files passed validation!")
        return 0


def main():
    if len(sys.argv) < 2:
        print("Usage: python validate.py <file_path>")
        print("       python validate.py --all")
        sys.exit(1)
    
    if sys.argv[1] == '--all':
        sys.exit(asyncio.run(validate_all()))
    else:
        sys.exit(asyncio.run(validate_file(sys.argv[1])))


if __name__ == '__main__':
    main()
"""
        
        # validate.py ìƒì„±
        script_path = Path('validate.py')
        with open(script_path, 'w', encoding='utf-8') as f:
            f.write(script_content)
        
        # ì‹¤í–‰ ê¶Œí•œ ì¶”ê°€ (Unix)
        if sys.platform != 'win32':
            os.chmod(script_path, 0o755)
        
        print(f"âœ… Validation script created: {script_path}")
        print("  Usage: python validate.py <file_path>")
        print("         python validate.py --all")
    
    def setup_ci_validation(self):
        """CI/CD íŒŒì´í”„ë¼ì¸ì— ê²€ì¦ ì¶”ê°€"""
        
        github_workflow = """name: Vision Guardian Validation

on:
  pull_request:
    types: [opened, synchronize]
  push:
    branches: [main, develop]

jobs:
  validate:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install notion-client sentence-transformers chromadb
    
    - name: Set up environment
      env:
        NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
        NOTION_VISION_DB: ${{ secrets.NOTION_VISION_DB }}
        NOTION_TASKS_DB: ${{ secrets.NOTION_TASKS_DB }}
        NOTION_VALIDATION_DB: ${{ secrets.NOTION_VALIDATION_DB }}
        NOTION_DASHBOARD_PAGE: ${{ secrets.NOTION_DASHBOARD_PAGE }}
      run: |
        echo "Environment configured"
    
    - name: Run Vision Guardian Validation
      run: |
        python validate.py --all
    
    - name: Upload validation report
      if: failure()
      uses: actions/upload-artifact@v3
      with:
        name: validation-report
        path: validation_report.json
"""
        
        # .github/workflows ë””ë ‰í† ë¦¬ ìƒì„±
        workflows_dir = Path('.github/workflows')
        workflows_dir.mkdir(parents=True, exist_ok=True)
        
        # workflow íŒŒì¼ ì‘ì„±
        workflow_path = workflows_dir / 'vision-guardian.yml'
        with open(workflow_path, 'w', encoding='utf-8') as f:
            f.write(github_workflow)
        
        print(f"âœ… GitHub Actions workflow created: {workflow_path}")


# ë©”ì¸ ì„¤ì • í•¨ìˆ˜
async def setup_complete_validation_system():
    """ì™„ì „í•œ ê²€ì¦ ì‹œìŠ¤í…œ ì„¤ì •"""
    
    print("ğŸš€ Setting up Vision Guardian Validation System...")
    
    # 1. ê±°ë²„ë„ŒìŠ¤ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    config = {
        'vision_db': os.getenv('NOTION_VISION_DB'),
        'tasks_db': os.getenv('NOTION_TASKS_DB'),
        'validation_db': os.getenv('NOTION_VALIDATION_DB'),
        'dashboard_page': os.getenv('NOTION_DASHBOARD_PAGE')
    }
    
    governance = NotionGovernanceIntegration(
        os.getenv('NOTION_TOKEN'),
        config
    )
    
    await governance.initialize_governance()
    
    # 2. Interceptor ì´ˆê¸°í™”
    interceptor = ClaudeCodeInterceptor(governance)
    
    # 3. Git hooks ì„¤ì¹˜
    interceptor.install_git_hooks()
    
    # 4. VS Code ì„¤ì • ìƒì„±
    interceptor.create_vscode_extension()
    
    # 5. ê²€ì¦ ìŠ¤í¬ë¦½íŠ¸ ìƒì„±
    interceptor.create_validation_script()
    
    # 6. CI/CD ì„¤ì •
    interceptor.setup_ci_validation()
    
    print("\nâœ… Vision Guardian Validation System Setup Complete!")
    print("\nğŸ“‹ Available validation methods:")
    print("  1. Git pre-commit hook (automatic)")
    print("  2. Manual validation: python validate.py <file>")
    print("  3. VS Code: Ctrl+Shift+V")
    print("  4. CI/CD: GitHub Actions")
    print("  5. File monitoring: Run 'python -m executive_control.monitor'")
    
    return interceptor


if __name__ == "__main__":
    # ì„¤ì • ì‹¤í–‰
    asyncio.run(setup_complete_validation_system())