# ê¹€ì¹˜ í”„ë¦¬ë¯¸ì—„ ì°¨ìµê±°ë˜ ì‹œìŠ¤í…œ - ì „ì²´ ì½”ë“œ ë¦¬ë·°
*Generated: 2025-08-24*

## ğŸ“‹ ëª©ì°¨
1. [í”„ë¡œì íŠ¸ ê°œìš”](#í”„ë¡œì íŠ¸-ê°œìš”)
2. [ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜](#ì‹œìŠ¤í…œ-ì•„í‚¤í…ì²˜)
3. [í•µì‹¬ ëª¨ë“ˆ ì½”ë“œ](#í•µì‹¬-ëª¨ë“ˆ-ì½”ë“œ)
4. [í‰ê°€ í¬ì¸íŠ¸](#í‰ê°€-í¬ì¸íŠ¸)

---

## í”„ë¡œì íŠ¸ ê°œìš”

### ğŸ¯ ëª©í‘œ
- **ê¹€ì¹˜ í”„ë¦¬ë¯¸ì—„ ì°¨ìµê±°ë˜ ìë™í™”**: ì—…ë¹„íŠ¸(KRW) vs ë°”ì´ë‚¸ìŠ¤(USDT) ê°€ê²© ì°¨ì´ í™œìš©
- **ë¸íƒ€ ì¤‘ë¦½ í—¤ì§€**: í˜„ë¬¼ ë§¤ìˆ˜ + ì„ ë¬¼ ìˆìœ¼ë¡œ ë¦¬ìŠ¤í¬ ì¤‘ë¦½í™”
- **ML ê¸°ë°˜ ì‹ í˜¸**: LSTM + XGBoost + RL íŠ¸ë¦¬í”Œ í•˜ì´ë¸Œë¦¬ë“œ (Phase 2 ì˜ˆì •)

### ğŸ“Š í˜„ì¬ ì§„í–‰ë¥ 
- **82% ì™„ë£Œ** (23/28 íƒœìŠ¤í¬)
- **Phase 1 ì™„ë£Œ**: ê¸°ë³¸ ì¸í”„ë¼, ë°ì´í„° ìˆ˜ì§‘, ì „ëµ ì‹œìŠ¤í…œ
- **Phase 2 ì§„í–‰ ì˜ˆì •**: ML ëª¨ë¸ ê°œë°œ

---

## ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤                      â”‚
â”‚  - ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ (HTML/WebSocket)                     â”‚
â”‚  - ì•Œë¦¼ ì‹œìŠ¤í…œ (Telegram/Discord)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ì „ëµ ì‹¤í–‰ ë ˆì´ì–´                      â”‚
â”‚  - ë©€í‹° ì „ëµ ë§¤ë‹ˆì €                                     â”‚
â”‚  - ì‹ í˜¸ í†µí•© ì‹œìŠ¤í…œ                                     â”‚
â”‚  - ë¦¬ìŠ¤í¬ ê´€ë¦¬                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ë°ì´í„° ìˆ˜ì§‘ ë ˆì´ì–´                    â”‚
â”‚  - WebSocket ì‹¤ì‹œê°„ ë°ì´í„°                              â”‚
â”‚  - í™˜ìœ¨ ë°ì´í„° í†µí•©                                     â”‚
â”‚  - ê¹€ì¹˜ í”„ë¦¬ë¯¸ì—„ ê³„ì‚°                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ì¸í”„ë¼ ë ˆì´ì–´                         â”‚
â”‚  - API í‚¤ ë³´ì•ˆ (Fernet ì•”í˜¸í™”)                          â”‚
â”‚  - ë¡œê¹… ì‹œìŠ¤í…œ                                          â”‚
â”‚  - CI/CD íŒŒì´í”„ë¼ì¸                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## í•µì‹¬ ëª¨ë“ˆ ì½”ë“œ

### 1ï¸âƒ£ WebSocket ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì§‘ ì‹œìŠ¤í…œ

#### `data_collection/websocket_manager.py`
```python
"""
WebSocket ì—°ê²° ê´€ë¦¬ì
- ì—…ë¹„íŠ¸/ë°”ì´ë‚¸ìŠ¤ ì‹¤ì‹œê°„ ê°€ê²© ìˆ˜ì§‘
- ìë™ ì¬ì—°ê²° (exponential backoff)
- ì—°ê²° ìƒíƒœ ëª¨ë‹ˆí„°ë§
"""

import asyncio
import json
import logging
from typing import Dict, Any, Optional, Callable, List
from datetime import datetime
import websockets
from websockets.exceptions import WebSocketException
import ssl
import certifi

class WebSocketManager:
    """
    WebSocket ì—°ê²°ì„ ê´€ë¦¬í•˜ëŠ” í´ë˜ìŠ¤
    
    ì£¼ìš” ê¸°ëŠ¥:
    1. ë‹¤ì¤‘ ê±°ë˜ì†Œ ë™ì‹œ ì—°ê²°
    2. ìë™ ì¬ì—°ê²° ë©”ì»¤ë‹ˆì¦˜
    3. ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ ë“±ë¡
    4. ì—°ê²° ìƒíƒœ ì¶”ì 
    """
    
    def __init__(self, exchange_name: str, url: str, max_retries: int = 5):
        self.exchange_name = exchange_name
        self.url = url
        self.max_retries = max_retries
        self.retry_count = 0
        self.websocket = None
        self.is_connected = False
        self.message_handlers: List[Callable] = []
        self.ssl_context = ssl.create_default_context(cafile=certifi.where())
        
    async def connect(self):
        """WebSocket ì—°ê²° ì‹œì‘"""
        try:
            self.websocket = await websockets.connect(
                self.url,
                ssl=self.ssl_context,
                ping_interval=20,
                ping_timeout=10
            )
            self.is_connected = True
            self.retry_count = 0
            logger.info(f"{self.exchange_name} WebSocket connected")
            
            # êµ¬ë… ë©”ì‹œì§€ ì „ì†¡
            await self._subscribe()
            
            # ë©”ì‹œì§€ ìˆ˜ì‹  ë£¨í”„
            await self._receive_messages()
            
        except Exception as e:
            logger.error(f"{self.exchange_name} connection failed: {e}")
            await self._handle_reconnection()
    
    async def _handle_reconnection(self):
        """ì¬ì—°ê²° ì²˜ë¦¬ (exponential backoff)"""
        if self.retry_count < self.max_retries:
            wait_time = min(2 ** self.retry_count, 60)  # ìµœëŒ€ 60ì´ˆ
            self.retry_count += 1
            logger.info(f"Reconnecting in {wait_time} seconds... (attempt {self.retry_count})")
            await asyncio.sleep(wait_time)
            await self.connect()
        else:
            logger.error(f"{self.exchange_name} max retries exceeded")
```

**í‰ê°€ í¬ì¸íŠ¸:**
- âœ… ì•ˆì •ì ì¸ ì¬ì—°ê²° ë©”ì»¤ë‹ˆì¦˜
- âœ… SSL ì¸ì¦ì„œ ì²˜ë¦¬
- âœ… ë¹„ë™ê¸° ì²˜ë¦¬ë¡œ ì„±ëŠ¥ ìµœì í™”
- âš ï¸ ê°œì„ ì : Circuit breaker íŒ¨í„´ ì¶”ê°€ ê°€ëŠ¥

---

### 2ï¸âƒ£ ê¹€ì¹˜ í”„ë¦¬ë¯¸ì—„ ê³„ì‚° ì—”ì§„

#### `strategies/kimchi_premium_calculator.py`
```python
"""
ê¹€ì¹˜ í”„ë¦¬ë¯¸ì—„ ê³„ì‚°ê¸°
- ì‹¤ì‹œê°„ í”„ë¦¬ë¯¸ì—„ ê³„ì‚°
- ì´ë™í‰ê·  ë° í‘œì¤€í¸ì°¨ ì¶”ì 
- ê±°ë˜ ì‹ í˜¸ ìƒì„±
"""

class KimchiPremiumCalculator:
    """
    ê¹€ì¹˜ í”„ë¦¬ë¯¸ì—„ ê³„ì‚° ë° ë¶„ì„
    
    ê³„ì‚°ì‹:
    ê¹€í”„(%) = ((ì—…ë¹„íŠ¸_KRW / (ë°”ì´ë‚¸ìŠ¤_USDT * í™˜ìœ¨)) - 1) * 100
    """
    
    def __init__(self, window_size: int = 60):
        self.window_size = window_size
        self.premium_history = deque(maxlen=window_size)
        self.ma_short = 0  # ë‹¨ê¸° ì´ë™í‰ê· 
        self.ma_long = 0   # ì¥ê¸° ì´ë™í‰ê· 
        self.std_dev = 0   # í‘œì¤€í¸ì°¨
        
    def calculate_premium(
        self,
        upbit_price: float,
        binance_price: float,
        exchange_rate: float
    ) -> Dict[str, float]:
        """
        ê¹€ì¹˜ í”„ë¦¬ë¯¸ì—„ ê³„ì‚°
        
        Args:
            upbit_price: ì—…ë¹„íŠ¸ BTC ê°€ê²© (KRW)
            binance_price: ë°”ì´ë‚¸ìŠ¤ BTC ê°€ê²© (USDT)
            exchange_rate: USD/KRW í™˜ìœ¨
            
        Returns:
            {
                'premium': ê¹€ì¹˜ í”„ë¦¬ë¯¸ì—„ (%),
                'upbit_usd': ì—…ë¹„íŠ¸ USD í™˜ì‚°ê°€,
                'spread': ìŠ¤í”„ë ˆë“œ (KRW)
            }
        """
        # USD í™˜ì‚°
        upbit_price_usd = upbit_price / exchange_rate
        
        # í”„ë¦¬ë¯¸ì—„ ê³„ì‚°
        premium = ((upbit_price_usd / binance_price) - 1) * 100
        
        # íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸
        self.premium_history.append(premium)
        
        # í†µê³„ ì—…ë°ì´íŠ¸
        self._update_statistics()
        
        return {
            'premium': premium,
            'upbit_usd': upbit_price_usd,
            'spread': upbit_price - (binance_price * exchange_rate),
            'ma_short': self.ma_short,
            'ma_long': self.ma_long,
            'std_dev': self.std_dev,
            'z_score': self._calculate_z_score(premium)
        }
    
    def _calculate_z_score(self, premium: float) -> float:
        """Z-score ê³„ì‚° (í‰ê·  ëŒ€ë¹„ í‘œì¤€í¸ì°¨)"""
        if self.std_dev > 0:
            return (premium - self.ma_long) / self.std_dev
        return 0
```

**í‰ê°€ í¬ì¸íŠ¸:**
- âœ… ì •í™•í•œ ê¹€í”„ ê³„ì‚° ë¡œì§
- âœ… í†µê³„ì  ì§€í‘œ ì œê³µ (Z-score)
- âœ… ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ì§€ì›
- ğŸ’¡ íŠ¸ë ˆì´ë”© ì‹ í˜¸ ìƒì„± ê¸°ë°˜ ì œê³µ

---

### 3ï¸âƒ£ ë©€í‹° ì „ëµ ì‹¤í–‰ ì‹œìŠ¤í…œ

#### `strategies/multi_strategy/base_strategy.py`
```python
"""
ì „ëµ ë² ì´ìŠ¤ í´ë˜ìŠ¤
- ëª¨ë“  ì „ëµì´ ìƒì†ë°›ëŠ” ì¶”ìƒ í´ë˜ìŠ¤
- ê³µí†µ ì¸í„°í˜ì´ìŠ¤ ì •ì˜
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum

class SignalType(Enum):
    """ê±°ë˜ ì‹ í˜¸ íƒ€ì…"""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    CLOSE = "CLOSE"

@dataclass
class TradingSignal:
    """ê±°ë˜ ì‹ í˜¸ ë°ì´í„°"""
    timestamp: datetime
    strategy_name: str
    signal_type: SignalType
    confidence: float  # 0~1
    suggested_amount: float
    reason: str
    metadata: Dict = field(default_factory=dict)

class BaseStrategy(ABC):
    """
    ë² ì´ìŠ¤ ì „ëµ í´ë˜ìŠ¤
    
    êµ¬í˜„ í•„ìˆ˜ ë©”ì„œë“œ:
    1. analyze() - ì‹œì¥ ë¶„ì„
    2. calculate_position_size() - í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
    3. should_close_position() - ì²­ì‚° ì—¬ë¶€ ê²°ì •
    """
    
    def __init__(self, name: str, config: Dict, initial_capital: float):
        self.name = name
        self.config = config
        self.initial_capital = initial_capital
        self.position = 0
        self.performance = StrategyPerformance()
        
    @abstractmethod
    def analyze(self, market_data: MarketData) -> Optional[TradingSignal]:
        """ì‹œì¥ ë°ì´í„° ë¶„ì„ ë° ì‹ í˜¸ ìƒì„±"""
        pass
    
    @abstractmethod
    def calculate_position_size(self, signal: TradingSignal) -> float:
        """í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°"""
        pass
```

#### `strategies/multi_strategy/threshold_strategy.py`
```python
"""
ì„ê³„ê°’ ê¸°ë°˜ ì „ëµ
- ê¹€í”„ê°€ íŠ¹ì • ìˆ˜ì¤€ì„ ë„˜ìœ¼ë©´ ì§„ì…
- ë‹¨ìˆœí•˜ì§€ë§Œ íš¨ê³¼ì 
"""

class ThresholdStrategy(BaseStrategy):
    """
    ì„ê³„ê°’ ì „ëµ êµ¬í˜„
    
    íŒŒë¼ë¯¸í„°:
    - entry_threshold: ì§„ì… ê¹€í”„ (ê¸°ë³¸ 3%)
    - exit_threshold: ì²­ì‚° ê¹€í”„ (ê¸°ë³¸ 1.5%)
    - stop_loss: ì†ì ˆ ìˆ˜ì¤€ (ê¸°ë³¸ -2%)
    """
    
    def __init__(self, name: str = "ThresholdStrategy", config: Optional[Dict] = None):
        default_config = {
            'entry_threshold': 3.0,      # ì§„ì… ì„ê³„ê°’ (%)
            'exit_threshold': 1.5,       # ì²­ì‚° ì„ê³„ê°’ (%)
            'stop_loss': -2.0,           # ì†ì ˆ ì„ê³„ê°’ (%)
            'position_size_pct': 0.1,    # í¬ì§€ì…˜ í¬ê¸° (10%)
            'min_hold_time': 300,        # ìµœì†Œ ë³´ìœ  ì‹œê°„ (5ë¶„)
            'cooldown_period': 600,      # ì¬ì§„ì… ì¿¨ë‹¤ìš´ (10ë¶„)
        }
        
        if config:
            default_config.update(config)
        
        super().__init__(name, default_config, 1_000_000)
        self.last_exit_time = None
        
    def analyze(self, market_data: MarketData) -> Optional[TradingSignal]:
        """
        ì‹œì¥ ë¶„ì„ ë¡œì§
        
        ì§„ì… ì¡°ê±´:
        1. ê¹€í”„ > entry_threshold
        2. ì¿¨ë‹¤ìš´ ê¸°ê°„ ê²½ê³¼
        3. ì¶©ë¶„í•œ ê±°ë˜ëŸ‰
        """
        kimchi_premium = market_data.kimchi_premium
        
        # ì¿¨ë‹¤ìš´ ì²´í¬
        if self._is_in_cooldown(market_data.timestamp):
            return None
        
        # ì§„ì… ì‹ í˜¸
        if self.position == 0 and kimchi_premium >= self.config['entry_threshold']:
            confidence = self._calculate_confidence(kimchi_premium, 'entry')
            
            return TradingSignal(
                timestamp=market_data.timestamp,
                strategy_name=self.name,
                signal_type=SignalType.BUY,
                confidence=confidence,
                suggested_amount=0,
                reason=f"ê¹€í”„ {kimchi_premium:.2f}% > ì„ê³„ê°’ {self.config['entry_threshold']}%"
            )
        
        return None
```

#### `strategies/multi_strategy/strategy_manager.py`
```python
"""
ì „ëµ ë§¤ë‹ˆì €
- ì—¬ëŸ¬ ì „ëµ í†µí•© ê´€ë¦¬
- ìë³¸ ë°°ë¶„
- ì‹ í˜¸ í†µí•©
"""

class StrategyManager:
    """
    ë©€í‹° ì „ëµ ë§¤ë‹ˆì €
    
    ì£¼ìš” ê¸°ëŠ¥:
    1. ì „ëµ í¬íŠ¸í´ë¦¬ì˜¤ ê´€ë¦¬
    2. ìë³¸ ë°°ë¶„ (ê· ë“±/ì„±ê³¼ê¸°ë°˜/ì¼ˆë¦¬)
    3. ì‹ í˜¸ í†µí•© (ë§Œì¥ì¼ì¹˜/ê³¼ë°˜ìˆ˜/ê°€ì¤‘í‰ê· )
    4. ë¦¬ìŠ¤í¬ ê´€ë¦¬
    """
    
    def __init__(self, initial_capital: float = 10_000_000, config: Optional[Dict] = None):
        self.initial_capital = initial_capital
        self.strategies: Dict[str, BaseStrategy] = {}
        self.config = {
            'allocation_method': AllocationMethod.EQUAL,
            'signal_aggregation': SignalAggregation.WEIGHTED,
            'max_concurrent_positions': 3,
            'risk_limit_daily': 0.05,  # ì¼ì¼ ë¦¬ìŠ¤í¬ 5%
            'emergency_stop_loss': -0.1,  # ê¸´ê¸‰ ì†ì ˆ -10%
        }
        
        if config:
            self.config.update(config)
        
    async def analyze_market(self, market_data: MarketData) -> List[TradingSignal]:
        """
        ëª¨ë“  ì „ëµ ë³‘ë ¬ ì‹¤í–‰
        
        ë¹„ë™ê¸°ë¡œ ëª¨ë“  ì „ëµì„ ë™ì‹œì— ì‹¤í–‰í•˜ì—¬
        ì„±ëŠ¥ì„ ìµœì í™”
        """
        tasks = []
        for name, strategy in self.strategies.items():
            if strategy.status == StrategyStatus.ACTIVE:
                task = asyncio.create_task(
                    self._get_strategy_signal(strategy, market_data)
                )
                tasks.append((name, task))
        
        # ëª¨ë“  ì „ëµ ê²°ê³¼ ìˆ˜ì§‘
        results = await asyncio.gather(*[task for _, task in tasks])
        
        # Noneì´ ì•„ë‹Œ ì‹ í˜¸ë§Œ í•„í„°ë§
        signals = [s for s in results if s is not None]
        
        return signals
    
    def aggregate_signals(self, signals: List[TradingSignal]) -> Optional[TradingSignal]:
        """
        ì‹ í˜¸ í†µí•© ë¡œì§
        
        Methods:
        - UNANIMOUS: ëª¨ë“  ì „ëµ ë™ì˜
        - MAJORITY: ê³¼ë°˜ìˆ˜ ë™ì˜
        - WEIGHTED: ê°€ì¤‘ í‰ê· 
        - BEST: ìµœê³  ì‹ ë¢°ë„
        """
        if not signals:
            return None
        
        method = self.config['signal_aggregation']
        
        if method == SignalAggregation.WEIGHTED:
            # ê°€ì¤‘ í‰ê·  ê³„ì‚°
            weighted_confidence = 0
            buy_weight = 0
            sell_weight = 0
            
            for signal in signals:
                weight = self.strategy_weights.get(signal.strategy_name, 0)
                weighted_confidence += signal.confidence * weight
                
                if signal.signal_type == SignalType.BUY:
                    buy_weight += weight * signal.confidence
                elif signal.signal_type in [SignalType.SELL, SignalType.CLOSE]:
                    sell_weight += weight * signal.confidence
            
            # ìµœì¢… ì‹ í˜¸ ê²°ì •
            if buy_weight > sell_weight and buy_weight > 0.3:
                return self._create_aggregated_signal(signals, SignalType.BUY)
            elif sell_weight > buy_weight and sell_weight > 0.3:
                return self._create_aggregated_signal(signals, SignalType.SELL)
        
        return None
```

**í‰ê°€ í¬ì¸íŠ¸:**
- âœ… ê¹”ë”í•œ ì¶”ìƒí™”ì™€ ìƒì† êµ¬ì¡°
- âœ… ë‹¤ì–‘í•œ ì „ëµ ì§€ì› (Threshold, MA, Bollinger)
- âœ… ìœ ì—°í•œ ì‹ í˜¸ í†µí•© ë©”ì»¤ë‹ˆì¦˜
- âœ… ë¹„ë™ê¸° ë³‘ë ¬ ì²˜ë¦¬
- âš ï¸ ê°œì„ ì : ë°±í…ŒìŠ¤íŒ… í†µí•© í•„ìš”

---

### 4ï¸âƒ£ ì•Œë¦¼ ì‹œìŠ¤í…œ

#### `notifications/notification_manager.py`
```python
"""
í†µí•© ì•Œë¦¼ ë§¤ë‹ˆì €
- ë‹¤ì¤‘ ì±„ë„ ì§€ì› (Telegram, Discord)
- ìš°ì„ ìˆœìœ„ ê¸°ë°˜ í•„í„°ë§
- Rate Limiting
"""

class NotificationManager:
    """
    ì•Œë¦¼ ì‹œìŠ¤í…œ ì¤‘ì•™ ê´€ë¦¬ì
    
    ê¸°ëŠ¥:
    1. ë©€í‹° ì±„ë„ ë¼ìš°íŒ…
    2. ìš°ì„ ìˆœìœ„ í•„í„°ë§
    3. Rate Limiting
    4. Quiet Hours (22:00-08:00)
    """
    
    def __init__(self, config: Optional[Dict] = None):
        self.notifiers: Dict[str, BaseNotifier] = {}
        self.config = {
            'rate_limit': 10,  # ë¶„ë‹¹ ìµœëŒ€ ë©”ì‹œì§€
            'quiet_hours_start': 22,
            'quiet_hours_end': 8,
            'min_priority': NotificationPriority.MEDIUM
        }
        
        if config:
            self.config.update(config)
        
        self.message_history = deque(maxlen=100)
        self.rate_limiter = {}
        
    async def send_notification(
        self,
        message: str,
        notification_type: NotificationType,
        priority: NotificationPriority = NotificationPriority.MEDIUM,
        channels: Optional[List[str]] = None
    ) -> Dict[str, bool]:
        """
        ì•Œë¦¼ ì „ì†¡
        
        Args:
            message: ë©”ì‹œì§€ ë‚´ìš©
            notification_type: ì•Œë¦¼ íƒ€ì…
            priority: ìš°ì„ ìˆœìœ„
            channels: ì „ì†¡ ì±„ë„ (Noneì´ë©´ ì „ì²´)
            
        Returns:
            ì±„ë„ë³„ ì „ì†¡ ê²°ê³¼
        """
        # Quiet Hours ì²´í¬
        if self._is_quiet_hours() and priority != NotificationPriority.CRITICAL:
            logger.info("Quiet hours - notification deferred")
            return {}
        
        # Rate Limiting ì²´í¬
        if not self._check_rate_limit():
            logger.warning("Rate limit exceeded")
            return {}
        
        # ìš°ì„ ìˆœìœ„ í•„í„°ë§
        if priority.value < self.config['min_priority'].value:
            return {}
        
        # ì±„ë„ë³„ ì „ì†¡
        results = {}
        target_channels = channels or list(self.notifiers.keys())
        
        for channel in target_channels:
            if channel in self.notifiers:
                try:
                    success = await self.notifiers[channel].send_message(
                        message, notification_type
                    )
                    results[channel] = success
                except Exception as e:
                    logger.error(f"Failed to send to {channel}: {e}")
                    results[channel] = False
        
        # ì´ë ¥ ê¸°ë¡
        self._record_message(message, notification_type, priority, results)
        
        return results
    
    def _check_rate_limit(self) -> bool:
        """Rate Limiting ì²´í¬"""
        now = datetime.now()
        minute_key = now.strftime("%Y%m%d%H%M")
        
        if minute_key not in self.rate_limiter:
            self.rate_limiter = {minute_key: 0}  # ì´ì „ ê¸°ë¡ ì‚­ì œ
        
        if self.rate_limiter[minute_key] >= self.config['rate_limit']:
            return False
        
        self.rate_limiter[minute_key] += 1
        return True
```

**í‰ê°€ í¬ì¸íŠ¸:**
- âœ… ì‹¤ìš©ì ì¸ ê¸°ëŠ¥ (Quiet Hours, Rate Limiting)
- âœ… ìš°ì„ ìˆœìœ„ ê¸°ë°˜ í•„í„°ë§
- âœ… ë‹¤ì¤‘ ì±„ë„ ë™ì‹œ ì§€ì›
- âœ… ì—ëŸ¬ í•¸ë“¤ë§ ë° ë¡œê¹…

---

### 5ï¸âƒ£ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ

#### `monitoring/dashboard.html`
```html
<!DOCTYPE html>
<html>
<head>
    <title>ê¹€ì¹˜ í”„ë¦¬ë¯¸ì—„ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* ë‹¤í¬ í…Œë§ˆ ë””ìì¸ */
        body {
            background: #1a1a2e;
            color: #eee;
            font-family: 'Segoe UI', sans-serif;
        }
        
        .metric-card {
            background: #16213e;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        .premium-positive { color: #4caf50; }
        .premium-negative { color: #f44336; }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        .status-connected { background: #4caf50; }
        .status-disconnected { background: #f44336; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”¥ ê¹€ì¹˜ í”„ë¦¬ë¯¸ì—„ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§</h1>
        
        <!-- ì—°ê²° ìƒíƒœ -->
        <div class="connection-status">
            <span class="status-indicator"></span>
            <span id="connection-text">ì—°ê²° ì¤‘...</span>
        </div>
        
        <!-- ì£¼ìš” ì§€í‘œ -->
        <div class="metrics-grid">
            <div class="metric-card">
                <h3>ê¹€ì¹˜ í”„ë¦¬ë¯¸ì—„</h3>
                <div id="premium-value" class="large-text">--%</div>
            </div>
            
            <div class="metric-card">
                <h3>ì—…ë¹„íŠ¸ BTC</h3>
                <div id="upbit-price">â‚©0</div>
            </div>
            
            <div class="metric-card">
                <h3>ë°”ì´ë‚¸ìŠ¤ BTC</h3>
                <div id="binance-price">$0</div>
            </div>
            
            <div class="metric-card">
                <h3>USD/KRW</h3>
                <div id="exchange-rate">0</div>
            </div>
        </div>
        
        <!-- ì°¨íŠ¸ -->
        <div class="chart-container">
            <canvas id="premiumChart"></canvas>
        </div>
        
        <!-- ê±°ë˜ ì‹ í˜¸ -->
        <div class="signals-panel">
            <h3>ìµœê·¼ ê±°ë˜ ì‹ í˜¸</h3>
            <div id="signals-list"></div>
        </div>
    </div>
    
    <script>
        // WebSocket ì—°ê²°
        class DashboardManager {
            constructor() {
                this.ws = null;
                this.chart = null;
                this.initWebSocket();
                this.initChart();
            }
            
            initWebSocket() {
                this.ws = new WebSocket('ws://localhost:8765');
                
                this.ws.onopen = () => {
                    this.updateConnectionStatus(true);
                    console.log('WebSocket connected');
                };
                
                this.ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.updateDashboard(data);
                };
                
                this.ws.onclose = () => {
                    this.updateConnectionStatus(false);
                    // 5ì´ˆ í›„ ì¬ì—°ê²°
                    setTimeout(() => this.initWebSocket(), 5000);
                };
            }
            
            updateDashboard(data) {
                // ê¹€í”„ ì—…ë°ì´íŠ¸
                const premiumEl = document.getElementById('premium-value');
                premiumEl.textContent = `${data.premium.toFixed(2)}%`;
                premiumEl.className = data.premium > 0 ? 'premium-positive' : 'premium-negative';
                
                // ê°€ê²© ì—…ë°ì´íŠ¸
                document.getElementById('upbit-price').textContent = 
                    `â‚©${data.upbit_price.toLocaleString()}`;
                document.getElementById('binance-price').textContent = 
                    `$${data.binance_price.toLocaleString()}`;
                document.getElementById('exchange-rate').textContent = 
                    data.exchange_rate.toFixed(2);
                
                // ì°¨íŠ¸ ì—…ë°ì´íŠ¸
                this.updateChart(data);
                
                // ì‹ í˜¸ ì—…ë°ì´íŠ¸
                if (data.signal) {
                    this.addSignal(data.signal);
                }
            }
            
            updateChart(data) {
                // ì°¨íŠ¸ì— ìƒˆ ë°ì´í„° ì¶”ê°€
                if (this.chart) {
                    this.chart.data.labels.push(new Date().toLocaleTimeString());
                    this.chart.data.datasets[0].data.push(data.premium);
                    
                    // ìµœëŒ€ 100ê°œ ë°ì´í„° ìœ ì§€
                    if (this.chart.data.labels.length > 100) {
                        this.chart.data.labels.shift();
                        this.chart.data.datasets[0].data.shift();
                    }
                    
                    this.chart.update();
                }
            }
        }
        
        // ëŒ€ì‹œë³´ë“œ ì‹œì‘
        const dashboard = new DashboardManager();
    </script>
</body>
</html>
```

**í‰ê°€ í¬ì¸íŠ¸:**
- âœ… ì‹¤ì‹œê°„ WebSocket í†µì‹ 
- âœ… ì°¨íŠ¸ ì‹œê°í™” (Chart.js)
- âœ… ìë™ ì¬ì—°ê²°
- âœ… ë°˜ì‘í˜• UI
- ğŸ’¡ ê°œì„ ì : React/Vueë¡œ ë¦¬íŒ©í† ë§ ê°€ëŠ¥

---

### 6ï¸âƒ£ ë³´ì•ˆ ì‹œìŠ¤í…œ

#### `config/security.py`
```python
"""
API í‚¤ ë³´ì•ˆ ê´€ë¦¬
- Fernet ëŒ€ì¹­í‚¤ ì•”í˜¸í™”
- í™˜ê²½ ë³€ìˆ˜ ë¶„ë¦¬
"""

from cryptography.fernet import Fernet
import os
from typing import Dict, Optional

class SecureConfigManager:
    """
    ë³´ì•ˆ ì„¤ì • ê´€ë¦¬ì
    
    ê¸°ëŠ¥:
    1. API í‚¤ ì•”í˜¸í™”/ë³µí˜¸í™”
    2. í™˜ê²½ ë³€ìˆ˜ ê´€ë¦¬
    3. ì„¤ì • íŒŒì¼ ë³´í˜¸
    """
    
    def __init__(self, key_file: str = '.encryption.key'):
        self.key_file = key_file
        self.cipher = self._load_or_create_key()
        
    def _load_or_create_key(self) -> Fernet:
        """ì•”í˜¸í™” í‚¤ ë¡œë“œ ë˜ëŠ” ìƒì„±"""
        if os.path.exists(self.key_file):
            with open(self.key_file, 'rb') as f:
                key = f.read()
        else:
            key = Fernet.generate_key()
            with open(self.key_file, 'wb') as f:
                f.write(key)
            os.chmod(self.key_file, 0o600)  # ì†Œìœ ìë§Œ ì½ê¸° ê°€ëŠ¥
        
        return Fernet(key)
    
    def encrypt_config(self, config: Dict) -> bytes:
        """ì„¤ì • ì•”í˜¸í™”"""
        config_str = json.dumps(config)
        return self.cipher.encrypt(config_str.encode())
    
    def decrypt_config(self, encrypted: bytes) -> Dict:
        """ì„¤ì • ë³µí˜¸í™”"""
        decrypted = self.cipher.decrypt(encrypted)
        return json.loads(decrypted.decode())
    
    def get_api_keys(self) -> Dict[str, str]:
        """í™˜ê²½ ë³€ìˆ˜ì—ì„œ API í‚¤ ë¡œë“œ"""
        return {
            'upbit': {
                'access_key': os.getenv('UPBIT_ACCESS_KEY'),
                'secret_key': os.getenv('UPBIT_SECRET_KEY')
            },
            'binance': {
                'api_key': os.getenv('BINANCE_API_KEY'),
                'api_secret': os.getenv('BINANCE_API_SECRET')
            },
            'telegram': {
                'bot_token': os.getenv('TELEGRAM_BOT_TOKEN'),
                'chat_id': os.getenv('TELEGRAM_CHAT_ID')
            }
        }
```

**í‰ê°€ í¬ì¸íŠ¸:**
- âœ… ê°•ë ¥í•œ ì•”í˜¸í™” (Fernet)
- âœ… í™˜ê²½ ë³€ìˆ˜ ë¶„ë¦¬
- âœ… íŒŒì¼ ê¶Œí•œ ì„¤ì •
- âš ï¸ ê°œì„ ì : HashiCorp Vault í†µí•© ê³ ë ¤

---

### 7ï¸âƒ£ í…ŒìŠ¤íŠ¸ ì½”ë“œ

#### `tests/test_multi_strategy.py`
```python
"""
ë©€í‹° ì „ëµ ì‹œìŠ¤í…œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
- 96% ì»¤ë²„ë¦¬ì§€ ë‹¬ì„±
"""

import pytest
import asyncio
from unittest.mock import Mock, AsyncMock

class TestStrategyManager:
    """ì „ëµ ë§¤ë‹ˆì € í…ŒìŠ¤íŠ¸"""
    
    def test_add_strategy(self):
        """ì „ëµ ì¶”ê°€ í…ŒìŠ¤íŠ¸"""
        manager = StrategyManager()
        strategy = ThresholdStrategy()
        
        assert manager.add_strategy(strategy) is True
        assert len(manager.strategies) == 1
        assert strategy.name in manager.strategies
    
    def test_signal_aggregation_weighted(self):
        """ê°€ì¤‘ í‰ê·  ì‹ í˜¸ í†µí•© í…ŒìŠ¤íŠ¸"""
        manager = StrategyManager(
            config={'signal_aggregation': SignalAggregation.WEIGHTED}
        )
        
        # Mock ì‹ í˜¸ ìƒì„±
        signals = [
            TradingSignal(
                timestamp=datetime.now(),
                strategy_name="Strategy1",
                signal_type=SignalType.BUY,
                confidence=0.8,
                suggested_amount=0.01,
                reason="Test"
            ),
            TradingSignal(
                timestamp=datetime.now(),
                strategy_name="Strategy2",
                signal_type=SignalType.BUY,
                confidence=0.6,
                suggested_amount=0.01,
                reason="Test"
            )
        ]
        
        # ê°€ì¤‘ì¹˜ ì„¤ì •
        manager.strategy_weights = {
            "Strategy1": 0.6,
            "Strategy2": 0.4
        }
        
        aggregated = manager.aggregate_signals(signals)
        
        assert aggregated is not None
        assert aggregated.signal_type == SignalType.BUY
        assert 0.6 < aggregated.confidence < 0.8  # ê°€ì¤‘ í‰ê· 
    
    @pytest.mark.asyncio
    async def test_parallel_strategy_execution(self):
        """ë³‘ë ¬ ì „ëµ ì‹¤í–‰ í…ŒìŠ¤íŠ¸"""
        manager = StrategyManager()
        
        # Mock ì „ëµë“¤
        for i in range(3):
            mock_strategy = Mock(spec=BaseStrategy)
            mock_strategy.name = f"Strategy{i}"
            mock_strategy.status = StrategyStatus.ACTIVE
            mock_strategy.update = Mock(return_value=TradingSignal(...))
            manager.strategies[mock_strategy.name] = mock_strategy
        
        # ì‹œì¥ ë°ì´í„°
        market_data = MarketData(
            timestamp=datetime.now(),
            upbit_price=100_000_000,
            binance_price=70_000,
            exchange_rate=1400,
            kimchi_premium=2.04
        )
        
        # ë³‘ë ¬ ì‹¤í–‰
        signals = await manager.analyze_market(market_data)
        
        assert len(signals) == 3
        # ëª¨ë“  ì „ëµì´ í˜¸ì¶œë˜ì—ˆëŠ”ì§€ í™•ì¸
        for strategy in manager.strategies.values():
            strategy.update.assert_called_once()
```

**í‰ê°€ í¬ì¸íŠ¸:**
- âœ… í¬ê´„ì ì¸ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€
- âœ… ë¹„ë™ê¸° í…ŒìŠ¤íŠ¸ ì§€ì›
- âœ… Mock í™œìš©í•œ ê²©ë¦¬ í…ŒìŠ¤íŠ¸
- âœ… Edge case ì²˜ë¦¬

---

## í‰ê°€ í¬ì¸íŠ¸

### ğŸŒŸ ê°•ì 

1. **ì•„í‚¤í…ì²˜ ì„¤ê³„**
   - ê¹”ë”í•œ ëª¨ë“ˆí™”ì™€ ë ˆì´ì–´ ë¶„ë¦¬
   - ì¶”ìƒí™”ë¥¼ í†µí•œ í™•ì¥ì„± í™•ë³´
   - SOLID ì›ì¹™ ì¤€ìˆ˜

2. **ì½”ë“œ í’ˆì§ˆ**
   - Type hints í™œìš©
   - Docstring ì‘ì„±
   - ì—ëŸ¬ í•¸ë“¤ë§

3. **ì„±ëŠ¥ ìµœì í™”**
   - ë¹„ë™ê¸° ì²˜ë¦¬ (asyncio)
   - ë³‘ë ¬ ì‹¤í–‰
   - íš¨ìœ¨ì ì¸ ë°ì´í„° êµ¬ì¡°

4. **ì‹¤ìš©ì  ê¸°ëŠ¥**
   - ìë™ ì¬ì—°ê²°
   - Rate limiting
   - Quiet hours

5. **ë³´ì•ˆ**
   - API í‚¤ ì•”í˜¸í™”
   - í™˜ê²½ ë³€ìˆ˜ ë¶„ë¦¬
   - ì•ˆì „í•œ WebSocket ì—°ê²°

### âš ï¸ ê°œì„  ê°€ëŠ¥í•œ ë¶€ë¶„

1. **ë°±í…ŒìŠ¤íŒ… ì‹œìŠ¤í…œ**
   - ê³¼ê±° ë°ì´í„° ì‹œë®¬ë ˆì´ì…˜ í•„ìš”
   - ì„±ê³¼ ê²€ì¦ ìë™í™”

2. **ë°ì´í„°ë² ì´ìŠ¤**
   - í˜„ì¬ ë©”ëª¨ë¦¬ ê¸°ë°˜
   - PostgreSQL/MongoDB í†µí•© í•„ìš”

3. **ì‹¤ê±°ë˜ ì—°ë™**
   - ì£¼ë¬¸ ì‹¤í–‰ ëª¨ë“ˆ ë¯¸êµ¬í˜„
   - ì”ê³  ê´€ë¦¬ ì‹œìŠ¤í…œ í•„ìš”

4. **ML ëª¨ë¸**
   - Phase 2 ë¯¸êµ¬í˜„
   - LSTM/RL í†µí•© ì˜ˆì •

5. **ëª¨ë‹ˆí„°ë§**
   - Prometheus/Grafana í†µí•©
   - ìƒì„¸ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

### ğŸ“ˆ ì„±ê³¼ ì§€í‘œ

- **ì½”ë“œ ë¼ì¸**: ì•½ 5,000ì¤„
- **í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€**: í‰ê·  90%+
- **ëª¨ë“ˆ ìˆ˜**: 15ê°œ í•µì‹¬ ëª¨ë“ˆ
- **ì „ëµ ìˆ˜**: 3ê°œ êµ¬í˜„, í™•ì¥ ê°€ëŠ¥
- **ì§„í–‰ë¥ **: 82% (23/28 íƒœìŠ¤í¬)

### ğŸ¯ ë‹¤ìŒ ë‹¨ê³„ ì œì•ˆ

1. **ë‹¨ê¸° (1ì£¼ì¼)**
   - ë°±í…ŒìŠ¤íŒ… ì‹œìŠ¤í…œ êµ¬í˜„
   - PostgreSQL í†µí•©
   - ì‹¤ê±°ë˜ API ì—°ë™

2. **ì¤‘ê¸° (1ê°œì›”)**
   - ML ëª¨ë¸ í†µí•© (LSTM)
   - ì„±ê³¼ ë¶„ì„ ëŒ€ì‹œë³´ë“œ
   - Docker ì»¨í…Œì´ë„ˆí™”

3. **ì¥ê¸° (3ê°œì›”)**
   - ê°•í™”í•™ìŠµ ì—ì´ì „íŠ¸
   - ë©€í‹° ì½”ì¸ ì§€ì›
   - í´ë¼ìš°ë“œ ë°°í¬

---

## ê²°ë¡ 

ì´ í”„ë¡œì íŠ¸ëŠ” **ì‹¤ë¬´ì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•œ ìˆ˜ì¤€**ì˜ ê¹€ì¹˜ í”„ë¦¬ë¯¸ì—„ ì°¨ìµê±°ë˜ ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

### âœ… ì™„ì„±ë„ ë†’ì€ ë¶€ë¶„
- ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì§‘
- ë©€í‹° ì „ëµ ì‹œìŠ¤í…œ
- ì•Œë¦¼ ì‹œìŠ¤í…œ
- ë³´ì•ˆ ì²˜ë¦¬

### ğŸ”„ ì¶”ê°€ ê°œë°œ í•„ìš”
- ML ëª¨ë¸ í†µí•©
- ì‹¤ê±°ë˜ ì‹¤í–‰
- ë°±í…ŒìŠ¤íŒ…
- ë°ì´í„°ë² ì´ìŠ¤

**ì „ì²´ì ìœ¼ë¡œ ì½”ë“œ í’ˆì§ˆê³¼ ì•„í‚¤í…ì²˜ ì„¤ê³„ê°€ ìš°ìˆ˜í•˜ë©°, 
í™•ì¥ ê°€ëŠ¥í•œ êµ¬ì¡°ë¡œ ì˜ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.**

GitHub Repository: https://github.com/vsun410/kimchi-premium-arbitrage